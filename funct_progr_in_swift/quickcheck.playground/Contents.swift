import Foundation

/*** QuickCheck (Claessen and Hughes 2000) is a Haskell library for random testing 
each of which tests that a function is correct for some particular input.
Quickcheck allows to describe abstract properties of your functions and generate
tests to verify these properties. When a property passes, it doesn't necessarily
prove that the property is correct. Rather, QquickCheck aims to find boundary
conditions that invalidate the property.
****/

//e.g. test that sum is commutative
func plusIsCommutative(x: Int, y: Int) -> Bool {
    return x + y == y + x
}

/** Building basic QuickCheck impl. in Swift. Steps:
1- We need a way to generate random values for different types.
2- Using random value generators, we need to implement the check function, which
passes random values to its argument property.
3- If a test fails, we would like to make the test input as small as possible. For example
if our test fails on an array with 100 elements, we'll try to make it smaller and 
see if the test still fails.
4- We'll need to do some extra work to make sure our check function works on types
that have generics. ***/


/** 1- generate random values
Let's define a protocol that knows how to generate arbitrary values. This protocol
contains only one function, arbitrary, which returns a value of type self ***/

//protocol Arbitrary {
//    static func arbitrary() -> Self
//}

//random integers
extension Int: Arbitrary {
    static func arbitrary() -> Int {
        return Int(arc4random())
    }
}

//random strings

func random(#from: Int, #to: Int) -> Int {
    return from + (Int(arc4random()) % (to-from))
}

extension Character: Arbitrary {
    //generate only capital letters as random chars.
    static func arbitrary() -> Character {
        return Character(UnicodeScalar(random(from: 65, to: 90)))
    }
    
    func smaller() -> Character? { return nil }
}

func tabulate<A>(times: Int, f: Int -> A) -> [A] {
    return Array(0..<times).map(f)
}

extension String: Arbitrary {
    static func arbitrary() -> String {
        let randomLength = random(from: 0, to: 40)
        let randomChars = tabulate(randomLength) {
            _ in Character.arbitrary()
        }
        return reduce(randomChars, "") { $0 + String($1) }
    }
}


/*** 2- Check function
Simple loop that generates random input for the argument property in every 
iteration. If a counterxample is found, it is printed, and the function returns; 
else, reports the number of successful tests that have passed.  ***/

protocol Smaller {
    func smaller() -> Self?
}

extension Int: Smaller {
    func smaller() -> Int? {
        return self == 0 ? nil : self/2
    }
}

extension String: Smaller {
    //drop first char if string is not empty
    func smaller() -> String? {
        return isEmpty ? nil : dropFirst(self)
    }
}

//to use the Smaller protocol in the check function, we will need the ability to
//shrink any test data generated by our check function, we need to redefine our
//arbitrary protocol to extends the Smaller protocol:

protocol Arbitrary: Smaller {
    static func arbitrary() -> Self
}


//Repeteadly shrinking

func iterateWhile<A>(condition: A -> Bool, initialValue: A, next: A -> A?) -> A {
    if let x = next(initialValue) where condition(x) {
        return iterateWhile(condition, x, next)
    }
    return initialValue
}


//Arbitrary arrays

extension Array: Smaller {
    func smaller() -> [T]? {
        if !isEmpty {
            return Array(dropFirst(self))
        }
        return nil
    }
}

func arbitraryArray<X: Arbitrary>() -> [X] {
    let randomLength = Int(arc4random() % 50)
    return tabulate(randomLength) { _ in return X.arbitrary() }
}

struct ArbitraryI<T> {
    let arbitrary: () -> T
    let smaller: T -> T?
}

let numberOfIterations = 100

func checkHelper<A>(arbitraryInstance: ArbitraryI<A>, prop: A -> Bool, message: String){
    for _ in 0..<numberOfIterations {
        let value = arbitraryInstance.arbitrary()
        if !prop(value) {
            let smallerValue = iterateWhile({ !prop($0) }, value, arbitraryInstance.smaller)
            println("\"\(message)\"doesn't hold: \(smallerValue)")
            return
        }
    }
    println("\"\(message)\" passed \(numberOfIterations) tests.")
}

func check<X: Arbitrary>(message: String, prop: X -> Bool) {
    let instance = ArbitraryI(arbitrary: { X.arbitrary() }, smaller: { $0.smaller() })
    checkHelper(instance, prop, message)
}

func check<X: Arbitrary>(message: String, prop: [X] -> Bool) {    let instance = ArbitraryI(
        arbitrary: arbitraryArray,        smaller: { (x: [X]) in x.smaller() }
    )    checkHelper(instance, prop, message)
}